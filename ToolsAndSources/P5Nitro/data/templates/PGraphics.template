import nme.Lib;
import nme.events.MouseEvent;
import nme.events.Event;
import nme.display.DisplayObject;
import nme.display.IGraphicsData;
import nme.display.BitmapData;
import nme.display.Bitmap;
import nme.display.GradientType;
import nme.display.Sprite;
import nme.display.LineScaleMode;
import nme.display.CapsStyle;
import nme.display.StageDisplayState;
import nme.display.JointStyle;
import nme.geom.Matrix;
import nme.geom.Point;
import nme.geom.Rectangle;
import nme.geom.ColorTransform;

import nme.display.Shape;

/*ifOpenGL
class PGraphics extends Sprite {
endifOpenGL*/

/*ifFlash
class PGraphics extends PImage {
endifFlash*/

		/*ifOpenGL
			// the image() method of the root pGraphics stores
			// a bitmap for each image (say, a letter drawn to screen).
			// If a number of images are drawn at each loop, we
			// prefer to reuse the Bitmap objects rather than having
			// to create new ones every time.
			// So we use the bitmapPool pool, and we have to mark
			// all entries available again at the beginning of each loop
			public var bitmapPool:ProcessingHaxeBitmapPool;
		endifOpenGL*/
		
		public var newShapeNeeded:Bool;

		public var pGraphicsAlpha:Int;

		// drawing constants
		public var PI:Float;
		public var TWO_PI:Float;
		public var HALF_PI:Float;
		public var P2D:Int;
		public var P3D:Int;
		public var CORNER:Int;
		public var RADIUS:Int;
		public var CENTER_RADIUS:Int;
		public var CENTER:Int;
		public var POLYGON:Int;
		public var QUADS:Int;
		public var TRIANGLES:Int;
		public var POINTS:Int;
		public var LINES:Int;
		public var TRIANGLE_STRIP:Int;
		public var TRIANGLE_FAN:Int;
		public var QUAD_STRIP:Int;
		public var CORNERS:Int;
		public var CLOSE:Bool;
		public var RGB:Int;
		public var HSB:Int;

		// private state variables
		private var hasBackground:Bool;
		private var curRectMode:Int;
		private var curEllipseMode:Int;
		private var curShape:Int;
		private var curShapeCount:Int;
		private var opacityRange:Int;
		private var redRange:Int;
		private var greenRange:Int;
		private var blueRange:Int;
		private var pathOpen:Bool;
		private var mousePressed:Bool;
		private var keyPressed:Bool;
		private var firstX:Float;
		private var firstY:Float;
		private var secondX:Float;
		private var secondY:Float;
		private var prevX:Float;
		private var prevY:Float;
		private var curColorMode:Int;
		public var tintColor:Int;
		private var curTextSize:Int;
		private var curTextFont:String;
		//private var getLoaded;

		// stroke
		private var doStroke:Bool;
		private var curStrokeWeight:Float;
		private var curStrokeColor:Int;
		//private var curStrokeCap:String = CapsStyle.ROUND;
		//private var curStrokeCap:String = CapsStyle.NONE;
		//private var curStrokeCap:String = CapsStyle.SQUARE;

		public var tint:Bool;

		// fill
		// these two should be private but can
		// be made public for debugging purposes
		private var doFill:Bool;
		private var curFillColor:Int;

		// shape drawing
		public var shape:Shape;
		public var shapeMatrix:Matrix;
		private var doSmooth:Bool;
		
		// These variables allow us to seperately remember scaling and rotation of each matrix in the stack
		// We could figure out the scaling and the rotation from a matrix, but it's kind of hard to figure
		// out how, so, in the meantime, we are keeping these variables.
		private var trackingScaleX:Float;
		private var trackingScaleY:Float;
		private var trackingRotation:Float;
		private var trackingTranslationX:Float;
		private var trackingTranslationY:Float;
		
		private var matrixStack:Array<Matrix>;
		private var trackingScaleXStack:Array<Float>;
		private var trackingScaleYStack:Array<Float>;
		private var trackingRotationStack:Array<Float>;
		private var trackingTranslationXStack:Array<Float>;
		private var trackingTranslationYStack:Array<Float>;

		private var curTightness:Float;
		private var curvePoints:Array<Point>;

		public var curBackground:Int;

		/*ifOpenGL
			public function getArgCount2( x:Int, y:Int):Int
			{
					// COMMENTEDOUTBECAUSEOFgetPixelAtERROR
					//return Lib.stage.getPixelAt(x, y);
					return 0;
			}
		
			public function setArgCount3( x:Int, y:Int, color:Int ):Void {
				//[TODO] should this instantly nullify pixels[] array?
				//	bitmapData.setPixel32(x, y, color);
				
				 var xy: Array<Float>;
				 var cols: Array<Int>;
				xy = [];
				cols = [];
				xy[0] = x;
				xy[1] = y;
				// ARGB to ABGR
				var a:Int = color >> 24 & 0xFF;
				var r:Int = color >> 16 & 0xFF;
				var g:Int = color >> 8 & 0xFF;
				var b:Int = color & 0xFF;
				//trace("color: " + "0x"+StringTools.hex(color, 8));
				//trace("a: " + "0x"+StringTools.hex(a, 2));
				//trace("r: " + "0x"+StringTools.hex(r, 2));
				//trace("g: " + "0x"+StringTools.hex(g, 2));
				//trace("b: " + "0x"+StringTools.hex(b, 2));
				cols[0] = (a << 24) | (b << 16) | (g << 8) | (r );
				//trace("color transf: " + "0x"+StringTools.hex(cols[0], 8));
				graphics.drawPoints(xy,cols,0,2);
			}
		endifOpenGL*/

		public function ellipseModeArgCount1( aEllipseMode:Int ):Void {
			curEllipseMode = aEllipseMode;
		}

		public function smoothArgCount0():Void{
			// in theory you'd like the quality do be defined on a
			// per-PGraphics object but it's not the case here,
			// there is only one stage and we tweak the
			// global quality there.
			//nme.display.stage.quality = nme.display.StageQuality.HIGH;
			//			Main.tweakStageQuality();
			Lib.stage.quality = nme.display.StageQuality.BEST;
		}

		public inline function endDrawArgCount0()
		{
			// note that in the flash case the function below
			// also draws the shape one last time to the bitmap
			// before popping the matrix		
			popMatrixWithoutCreatingNewShape();
		}

		public function beginDrawArgCount0()
		{
			/*ifOpenGL		
				// Remove all the children shapes from the sprite
				// todo : this little loop currently consumes 24% of the running time of
				// simple sketches. Probably need to keep
				// 50 shapes or so that you always keep in an array and just clear the ones
				// you have used in each draw loop by doing a clear.
				// Also - for translates you might be better off just handling them manually and
				// adding the deltax and deltay to all the points you receive.
				if(numChildren!=0){
					var k:Int = numChildren;
					do {
						k--;
						//trace(" removing child " + k +  " " );
						removeChildAt( k );
					}
					while( k != 0 );
				}
				
				pushMatrixArgCount0();
			endifOpenGL*/
	
			/*ifFlash
			    // in the case of flash you don't need to reset
			    // the shape cause the one you get at the beginning of
			    // the for loop is already clean
			    // (it's been cleaned when the last shape of the
			    // previous draw loop has been drawn)
				pushMatrixWithoutCreatingNewShape();
			endifFlash*/

			// clear graphics and reset background
			if ( hasBackground )
			{
				backgroundArgCount0();
			}
		}

		public function sinArgCount1( aNumber: Float  ):Float {
				return Math.sin(aNumber);
		}
	
		public function cosArgCount1( aNumber: Float  ):Float {
				return Math.cos(aNumber);
		}

		public function randomArgCount2( aMin: Float, aMax:Float  ):Float {
				return aMin + (Math.random() * (aMax - aMin)) ;
		}

		public function backgroundArgCount4(r:Int,g:Int,b:Int,a:Int) {
			curBackground = colorArgCount4( r,g,b,a );
			/*ifOpenGL
			// todo
			endifOpenGL*/
			
			/*ifFlash
			bitmapData.fillRect(new Rectangle(0, 0, Std.int(width), Std.int(height)), curBackground);
			endifFlash*/
		}

		public function backgroundArgCount3(r:Int,g:Int,b:Int) {
			curBackground = colorArgCount3(r,g,b);
			/*ifOpenGL
			// todo
				createNewShape();
				shape.graphics.lineStyle();
				shape.graphics.beginFill(curBackground, 1.0);
				shape.graphics.drawRect(0,0,320,480);
				shape.graphics.endFill();
				// todo do you really need a new shape?
				newShapeNeeded = true;
			endifOpenGL*/
			
			/*ifFlash
			bitmapData.fillRect(new Rectangle(0, 0, Std.int(width), Std.int(height)), curBackground);
			endifFlash*/
		}

		public function backgroundArgCount2(shadeOfGray:Int,a:Int) {
			curBackground = colorArgCount2( shadeOfGray,a );
			/*ifOpenGL
			// todo
			endifOpenGL*/
			
			/*ifFlash
			bitmapData.fillRect(new Rectangle(0, 0, Std.int(width), Std.int(height)), curBackground);
			endifFlash*/
		}

		public function backgroundArgCount1(shadeOfGray:Int) {
			curBackground = colorArgCount1( shadeOfGray );
			/*ifOpenGL
			// todo
				createNewShape();
				shape.graphics.lineStyle();
				shape.graphics.beginFill(curBackground);
				shape.graphics.drawRect(0,0,320,480);
				shape.graphics.endFill();
				newShapeNeeded = true;
				
			endifOpenGL*/
			
			/*ifFlash
			bitmapData.fillRect(new Rectangle(0, 0, Std.int(width), Std.int(height)), curBackground);
			endifFlash*/
		}

		public function backgroundArgCount0() {
			/*ifOpenGL
				// todo
				createNewShape();
				shape.graphics.lineStyle();
				shape.graphics.beginFill(curBackground & 0xFFFFFF, pGraphicsAlphaMethod(curBackground) / 255);
				shape.graphics.drawRect(0,0,320,480);
				shape.graphics.endFill();
				newShapeNeeded = true;
			endifOpenGL*/
			
			/*ifFlash
			bitmapData.fillRect(new Rectangle(0, 0, Std.int(width), Std.int(height)), curBackground);
			endifFlash*/
		}


    public function new( ?x : Int, ?y : Int ) {
		/*ifFlash
			//trace("creating the bitmap version of pGraphics");
			x = (x == null) ? 320 : x; // "x" is optional
			y = (y == null) ? 480 : y; // "y" is optional
			super(x,y);
		endifFlash*/

		/*ifOpenGL
			super();
			// the image() method of the root pGraphics stores
			// a bitmap for each image (say, a letter drawn to screen).
			// If a number of images are drawn at each loop, we
			// prefer to reuse the Bitmap objects rather than having
			// to create new ones every time.
			// We create the pool here
			bitmapPool = new ProcessingHaxeBitmapPool(); 
			bitmapPool.initialize(1,1); 
		endifOpenGL*/
		
		newShapeNeeded = true;

		//smoothing = true;
		
		pGraphicsAlpha = 0;

		PI = 3.141592;
		TWO_PI = 2*PI;
		HALF_PI = PI/2.0;
		P2D = 2;
		P3D = 3;
		CORNER = 0;
		RADIUS = 1;
		CENTER_RADIUS = 1;
		CENTER = 2;
		POLYGON = 2;
		QUADS = 5;
		TRIANGLES = 6;
		POINTS = 7;
		LINES = 8;
		TRIANGLE_STRIP = 9;
		TRIANGLE_FAN = 4;
		QUAD_STRIP = 3;
		CORNERS = 10;
		CLOSE = true;
		RGB = 1;
		HSB = 2;

		// private state variables
		hasBackground = false;
		curRectMode = CORNER;
		curEllipseMode = CENTER;
		curShape = POLYGON;
		curShapeCount = 0;
		opacityRange = 255;
		redRange = 255;
		greenRange = 255;
		blueRange = 255;
		pathOpen = false;
		mousePressed = false;
		keyPressed = false;
		firstX = 0.0;
		firstY = 0.0;
		secondX = 0.0;
		secondY = 0.0;
		prevX = 0.0;
		prevY = 0.0;
		curColorMode = RGB;
		tintColor = 0xffffffff;
		curTextSize = 12;
		curTextFont = "Arial";
		//getLoaded;

		// stroke
		doStroke = true;
		curStrokeWeight = 1;
		curStrokeColor = 0xFF000000;
		//curStrokeCap:String = CapsStyle.ROUND;
		//curStrokeCap:String = CapsStyle.NONE;
		//curStrokeCap:String = CapsStyle.SQUARE;

		tint = false;

		// fill
		doFill = true;
		curFillColor = 0xFFFFFFFF;

		// shape drawing
		/*ifFlash
			// in openGL we provide to add a shape for each
			// graphic command, so we don't need this, we'll
			// fill it in ourselves when processing the first
			// graphic command
			shape = new Shape();
		endifFlash*/
		shapeMatrix = new Matrix();
		doSmooth = false;
		
		// These variables allow us to seperately remember scaling and rotation of each matrix in the stack
		// We could figure out the scaling and the rotation from a matrix, but it's kind of hard to figure
		// out how, so, in the meantime, we are keeping these variables.
		trackingScaleX = 1.0;
		trackingScaleY = 1.0;
		trackingRotation = 0.0;
		trackingTranslationX = 0.0;
		trackingTranslationY = 0.0;
		
		matrixStack = new Array<Matrix>();
		trackingScaleXStack = new Array<Float>();
		trackingScaleYStack = new Array<Float>();
		trackingRotationStack = new Array<Float>();
		trackingTranslationXStack = new Array<Float>();
		trackingTranslationYStack = new Array<Float>();
		
		curTightness = 0;
		curvePoints = new Array<Point>();
		
		
		curBackground = colorArgCount1(214);
		// todo : optimisation: we don't need this background
		// if the draw method already starts with a background() command
		backgroundArgCount0();

	}
    
		public function imageArgCount3( img:PImage, x:Int , y:Int ) //, w:int = undefined, h:int = undefined )
		{
				// create transformaton matrix
				//var matrix:Matrix = new Matrix();
				// translation
				//translateArgCount2(x, y);
				// scaling
				//if (arguments.length == 5)
				//	matrix.scale(w/img.width, h/img.height);
		
				var keepingTheOriginalMatrix:Matrix = shapeMatrix.clone();
				//shapeMatrix.translate(x, y);
				translateArgCount2(x, y);

			/*ifFlash
				// I don't think that resyncing the image is needed
				// - if the user wants to, he should call updatePixels
				// explicitely. So I'm going to comment this.
				// img.updatePixelsArgCount0();
			endifFlash*/

			/*ifOpenGL
			    // note that you have to create a new bitmap object
			    // linked to the passed Image, because you might
			    // want to draw the image multiple times, so you need
			    // to be able to control where each instance is.
			    
			    // unpooled Bitmaps solution
                // var imageCopy:Bitmap = new Bitmap(img.bitmapData);

                // pooled bitmaps solution
				// the image() method of the root pGraphics stores
				// a bitmap for each image (say, a letter drawn to screen).
				// If a number of images are drawn at each loop, we
				// prefer to reuse the Bitmap objects rather than having
				// to create new ones every time.
				// So here we get a free Bitmap from the pool
				// rather than creating it anew
                var imageCopy:Bitmap = bitmapPool.getBitmap();
                imageCopy.bitmapData = img.bitmapData;
			endifOpenGL*/

			if (tint) {
			    var aa:Int = tintColor >> 24 & 0xFF;
				var rr:Int = tintColor >> 16 & 0xFF;
				var gg:Int = tintColor >> 8 & 0xFF;
				var bb:Int = tintColor & 0xFF;	
				/*ifFlash
					// again, another weird swap in the software renderer
					//bitmapData.draw(img.bitmapData, shapeMatrix, new ColorTransform(rr/255, gg/255, bb/255, aa/255, 0, 0, 0, 0));
					bitmapData.draw(img.bitmapData, shapeMatrix, new ColorTransform(bb/255, gg/255, rr/255, aa/255, 0, 0, 0, 0));
				endifFlash*/
	
				/*ifOpenGL
					imageCopy.transform.colorTransform = new ColorTransform(rr/255, gg/255, bb/255, aa/255, 0, 0, 0, 0);
				endifOpenGL*/
			}
			else {
				/*ifFlash
					bitmapData.draw(img.bitmapData, shapeMatrix);
				endifFlash*/
			}


			/*ifOpenGL
				var newMatrix:Matrix = shapeMatrix.clone();
				imageCopy.transform.matrix = newMatrix;
				addChild(imageCopy);
			endifOpenGL*/

			//shapeMatrix.translate(-x, -y);
			shapeMatrix = keepingTheOriginalMatrix;
		}

		public function noTintArgCount0() {
			tint = false;
		}

		public function tintArgCount3( rc:Float, gc:Float, bc:Float ) {
			tint = true;
			tintColor = colorArgCount3( Std.int(rc),Std.int(gc),Std.int(bc) );
		}


		public function tintArgCount4( rc:Float, gc:Float, bc:Float, ac:Float ) {
			tint = true;
			tintColor = colorArgCount4( Std.int(rc),Std.int(gc),Std.int(bc),Std.int(ac));
		}


	public function createGraphicsArgCount3( w:Int, h:Int, type:Int):PGraphics {
		// As of now any pGraphics that is not the root one
		// does software rendering to a bitmap
		// In theory you could draw on an off-screen buffer
		// via OpenGL, then turn that off-screen buffer to texture
		// and draw the texture into a quad on the on-screen buffer.
		// That in theory should be faster but it's not how
		// it works now.
		// So this function will create a pGraphics object backed up by
		// a bitmap and any drawing primitives are software-rendered.
		var thepGraphics:PGraphics = new PGraphics(w, h);
		thepGraphics.cacheAsBitmap = true;
		
		// ok now paint the pGraphics black
		var rect:Rectangle = new Rectangle(0, 0, w, h);
		thepGraphics.bitmapData.fillRect(rect, 0xFF000000);
		return thepGraphics;
	}

	public function redArgCount1( aColor:Int ):Int {
		return aColor >> 16 & 0xFF;
	}
	
	public function greenArgCount1( aColor:Int ):Int {
		return aColor >> 8 & 0xFF;
	}
	
	public function blueArgCount1( aColor:Int ):Int {
		return aColor & 0xFF;
	}
	
	public function alphaArgCount1( aColor:Int ):Int {
		return aColor >> 24 & 0xFF;
	}

	public  function pGraphicsAlphaMethod( aColor:Int ):Int {
		return aColor >> 24 & 0xFF;
	}

	/*ifFlash
		public inline function drawShapeToBitmapAndClearShape():Void {	
			bitmapData.draw(shape, shapeMatrix, null, null, null, true);
			shape.graphics.clear();
		}
	endifFlash*/


	private function beginShapeDrawing():Void {	
		//shape.graphics.lineStyle(5, 0xff00ff, 100, true, "none", "round", "miter", 1);
		//shape.graphics.lineStyle(2,0x00FF00, 100, true, LineScaleMode.NONE, CapsStyle.ROUND, JointStyle.MITER, 1);

		//public function lineStyle(?thickness:Null<Float>, color:Int = 0, alpha:Float = 1.0,
		//                   pixelHinting:Bool = false, ?scaleMode:LineScaleMode, ?caps:CapsStyle,
		//                   ?joints:JointStyle, miterLimit:Float = 3) : Void
        	
        	// a new shape is needed only when a matrix operation
        	// happens, since shapes only operate on one transformation
        	// i.e. you can't change the transformations within the
        	// same shape.

				/*ifOpenGL
					createNewShape();
				endifOpenGL*/
				/*ifFlash
					drawShapeToBitmapAndClearShape();
				endifFlash*/
				
				newShapeNeeded = false;					
				
				// set the fill and stroke again
				// only if a new shape has been created
				// (which is when matrix operations happen)

				// set stroke
				if (doStroke)
					shape.graphics.lineStyle(curStrokeWeight , curStrokeColor & 0xFFFFFF,
						pGraphicsAlphaMethod(curStrokeColor) / 255,  LineScaleMode.NONE, CapsStyle.ROUND);
	
				// set fill
				if (doFill)
					shape.graphics.beginFill(curFillColor & 0xFFFFFF, pGraphicsAlphaMethod(curFillColor) / 255);

	}
	
	private inline function endAnyOpenFills():Void {
		// end any open fill
		shape.graphics.endFill();
	}

	public function lineArgCount4( x1:Float = 0, y1:Float = 0, x2:Float = 0, y2:Float = 0):Void {

		//trace("entering the line method params: " + x1 + " " + y1 + " " + x2 + " " + y2);
		if (newShapeNeeded) beginShapeDrawing();
		shape.graphics.moveTo( x1, y1 );
		shape.graphics.lineTo( x2, y2 );
		//endAnyOpenFills();
		
		// trying amazingly fast graphics
		//graphics.lineStyle(2,0x00FF00, 100, true, nme.display.LineScaleMode.NONE, nme.display.CapsStyle.ROUND, nme.display.JointStyle.MITER, 1);
		//graphics.moveTo( x1, y1 );
		//graphics.lineTo( x2, y2 );
		//bitmapData.draw(shape, shapeMatrix, null, null, null, true);
		//shape.graphics.clear();

	}

	public function rectArgCount4( x:Float, y:Float, width:Float, height:Float )
	{
		if (doStroke) {
			x += curStrokeWeight;
			y += curStrokeWeight;
			width -= curStrokeWeight;
			height -= curStrokeWeight;
		}
		//width += Math.sqrt(trackingScaleX)/16;
		//height += Math.sqrt(trackingScaleY)/16;

		// modify rectange mode
		switch (curRectMode)
		{
			case CORNERS:
			width -= x;
			height -= y;

			case RADIUS:
			width *= 2;
			height *= 2;
			case CENTER:
			x -= (width / 2);
			y -= (height / 2);

			default:
		}

		// draw shape
		if (newShapeNeeded) beginShapeDrawing();
		shape.graphics.drawRect(x, y, width, height);
		//endAnyOpenFills();
	}

		public function triangleArgCount6( x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float )
		{
			if (newShapeNeeded) beginShapeDrawing();
			beginShapeArgCount0();
			vertexArgCount2( x1, y1 );
			vertexArgCount2( x2, y2 );
			vertexArgCount2( x3, y3 );
			endShapeArgCount0();
		}


		public function ellipse( x:Float, y:Float, width:Float, height:Float )
		{
			//trace("ellipsemode: " + curEllipseMode);
			// modify ellipse mode
			width /= 2;
			height /= 2;

			switch (curEllipseMode)
			{

			    case CORNER:
				//trace("corner");
				x += width;
				y += height;

			    case RADIUS:
				//trace("radius");
				width *= 2;
				height *= 2;

			    case CENTER:
				//trace("center");

			    case CORNERS:
				//trace("corners");
				width /= 4;
				height /= 4;
				x += width;
				y += height;
			}

			// draw shape
			if (newShapeNeeded) beginShapeDrawing();
			shape.graphics.drawEllipse(x, y, width, height);
			//endAnyOpenFills();
		}

		public function noStrokeArgCount0() {
			doStroke = false;
			shape.graphics.lineStyle();
		}

		public function strokeArgCount4( r:Int,g:Int,b:Int, a:Int):Void
		{
			doStroke = true;
			curStrokeColor = colorArgCount4( r,g,b,a);
				shape.graphics.lineStyle(curStrokeWeight , curStrokeColor & 0xFFFFFF,
				    pGraphicsAlphaMethod(curStrokeColor) / 255,  LineScaleMode.NONE, CapsStyle.ROUND);
		}

		public function strokeArgCount3( r:Int,g:Int,b:Int):Void
		{
			doStroke = true;
			curStrokeColor = colorArgCount3( r,g,b );
				shape.graphics.lineStyle(curStrokeWeight , curStrokeColor & 0xFFFFFF,
				    pGraphicsAlphaMethod(curStrokeColor) / 255,  LineScaleMode.NONE, CapsStyle.ROUND);
		}

		public function strokeArgCount2( grayScale:Int,a:Int):Void
		{
			doStroke = true;
			curStrokeColor = colorArgCount2( grayScale, a );
				shape.graphics.lineStyle(curStrokeWeight , curStrokeColor & 0xFFFFFF,
				    pGraphicsAlphaMethod(curStrokeColor) / 255,  LineScaleMode.NONE, CapsStyle.ROUND);
		}

		public function strokeArgCount1( grayScale:Int):Void
		{
			doStroke = true;
			curStrokeColor = colorArgCount1( grayScale );
				shape.graphics.lineStyle(curStrokeWeight , curStrokeColor & 0xFFFFFF,
				    pGraphicsAlphaMethod(curStrokeColor) / 255,  LineScaleMode.NONE, CapsStyle.ROUND);
		}

		public function noFillArgCount0()
		{
			doFill = false;
			shape.graphics.endFill();
		}

		public function fillArgCount4( mr:Int,mg:Int,mb:Int, ma:Int):Void
		{
			doFill = true;
			curFillColor = colorArgCount4( mr,mg,mb,ma);
			shape.graphics.beginFill(curFillColor & 0xFFFFFF, pGraphicsAlphaMethod(curFillColor) / 255);
		}

		public function fillArgCount3( r:Int,g:Int,b:Int):Void
		{
			doFill = true;
			curFillColor = colorArgCount3( r,g,b);
			shape.graphics.beginFill(curFillColor & 0xFFFFFF, 1.0);
		}

		public function fillArgCount2( grayScale:Int,a:Int):Void
		{
			doFill = true;
			curFillColor = colorArgCount2( grayScale, a );
				shape.graphics.beginFill(curFillColor & 0xFFFFFF, pGraphicsAlphaMethod(curFillColor) / 255);
		}

		public function fillArgCount1( grayScale:Int):Void
		{
			doFill = true;
			curFillColor = colorArgCount1( grayScale );
			shape.graphics.beginFill(curFillColor & 0xFFFFFF, pGraphicsAlphaMethod(curFillColor) / 255);
		}


		public function colorArgCount1(shadeOfGray:Int):Int {
				// fit colors into range
				var r = getColor(shadeOfGray, redRange);

				// normalize color values
				//var colors = (curColorMode == HSB) ?
				//    HSBtoRGB(360*Number(r)/255, 100*Number(g)/255, 100*Number(b)/255) : [r,g,b];

				return (opacityRange << 24) + (r << 16) + (r << 8) + r;
		}

		public function colorArgCount2(shadeOfGray:Int,a:Int):Int {
				// fit colors into range
				var r:Int = getColor(shadeOfGray, redRange);

				// normalize color values
				//var colors = (curColorMode == HSB) ?
				//    HSBtoRGB(360*Number(r)/255, 100*Number(g)/255, 100*Number(b)/255) : [r,g,b];

				return (a << 24) + (r << 16) + (r << 8) + r;
		}

		public function colorArgCount3(r:Int,g:Int,b:Int):Int {
				// fit colors into range
				var r:Int = getColor(r, redRange);
				var g:Int = getColor(g, greenRange);
				var b:Int = getColor(b, blueRange);

				// normalize color values
				//var colors = (curColorMode == HSB) ?
				//    HSBtoRGB(360*Number(r)/255, 100*Number(g)/255, 100*Number(b)/255) : [r,g,b];

				// note: rgb are inverted from the flash implementation
				// (i.e. r and b are swapped)
				/*ifOpenGL
					return (opacityRange << 24) + (r << 16) + (g << 8) + b;
				endifOpenGL*/
				/*ifFlash
					//return (opacityRange << 24) + (b << 16) + (g << 8) + r;
					return (opacityRange << 24) + (r << 16) + (g << 8) + b;
				endifFlash*/
		}

		public function colorArgCount4(theR:Int,theG:Int,theB:Int,theA:Int):Int {
				// fit colors into range
				var r:Int = getColor(theR, redRange);
				var g:Int = getColor(theG, greenRange);
				var b:Int = getColor(theB, blueRange);
				var a:Int = getColor(theA, opacityRange);

				// normalize color values
				//var colors = (curColorMode == HSB) ?
				//    HSBtoRGB(360*Number(r)/255, 100*Number(g)/255, 100*Number(b)/255) : [r,g,b];

				// note: rgb are inverted from the flash implementation
				// (i.e. r and b are swapped)
				/*ifOpenGL
					return (a << 24) + (r << 16) + (g << 8) + b;
				endifOpenGL*/
				/*ifFlash
					//return (a << 24) + (b << 16) + (g << 8) + r;
					return (a << 24) + (r << 16) + (g << 8) + b;
				endifFlash*/
		}

		private inline function getColor( aValue:Int, range:Int ):Int {
			return Std.int(255 * (aValue / range));
			//return PMath.constrain(255 * (aValue / range), 0, 255);
		}
		

		public inline function pushMatrixWithoutCreatingNewShape(): Void
		{
			matrixStack.push(shapeMatrix);
			//matrixStack.push(shapeMatrix.clone());

			var newMatrix:Matrix = shapeMatrix.clone();
			shapeMatrix = newMatrix;

			// note that we don't need to draw the shape
			// to the bitmap in the flash case because
			// the geometry matrix is not changing just yet
			
			trackingScaleXStack.push(trackingScaleX);
			trackingScaleYStack.push(trackingScaleY);
			trackingRotationStack.push(trackingRotation);
			trackingTranslationXStack.push(trackingTranslationX);
			trackingTranslationYStack.push(trackingTranslationY);

		}
		
		public function pushMatrixArgCount0(): Void
		{
			// note that we don't need to draw the shape
			// to the bitmap in the flash case because
			// the geometry matrix is not changing just yet
			
			pushMatrixWithoutCreatingNewShape();
			newShapeNeeded = true;

		}
		
		
		public inline function popMatrixWithoutCreatingNewShape(): Void {

			/*ifFlash
				// draw the shape to bitmap before we
				// change the transformation matrix
				drawShapeToBitmapAndClearShape();
			endifFlash*/

			trackingTranslationY = trackingTranslationYStack.pop();
			trackingTranslationX = trackingTranslationXStack.pop();
			trackingRotation = trackingRotationStack.pop();
			trackingScaleY = trackingScaleYStack.pop();
			trackingScaleX = trackingScaleXStack.pop();

			shapeMatrix = matrixStack.pop();
		}
		
		public function popMatrixArgCount0(): Void
		{
			popMatrixWithoutCreatingNewShape();
			newShapeNeeded = true;

		}


		public function rotateArgCount1( aAngle:Float ):Void
		{
			/*ifFlash
				// draw the shape to bitmap before we
				// change the transformation matrix
				drawShapeToBitmapAndClearShape();
			endifFlash*/

			var newMatrix:Matrix = new Matrix();
			newMatrix.rotate(aAngle);
			newMatrix.concat(shapeMatrix);
			shapeMatrix = newMatrix;
			
			trackingRotation += aAngle;
			newShapeNeeded = true;

		}

		public function scaleArgCount2( x:Float, y:Float ):Void
		{
			/*ifFlash
				// draw the shape to bitmap before we
				// change the transformation matrix
				drawShapeToBitmapAndClearShape();
			endifFlash*/

			var newMatrix:Matrix = new Matrix();
			newMatrix.scale(x, y);
			newMatrix.concat(shapeMatrix);
			shapeMatrix = newMatrix;
			
			trackingScaleX *= x;
			trackingScaleY *= y;

			newShapeNeeded = true;
		}

		/*ifOpenGL
			public inline function createNewShape():Void
			{
					// to do try to invert these two lines
					shape = new Shape();
					this.addChild(shape);
					shape.transform.matrix = shapeMatrix;
			}
		endifOpenGL*/

		public function scaleArgCount1( xy:Float ):Void
		{
			/*ifFlash
				// draw the shape to bitmap before we
				// change the transformation matrix
				drawShapeToBitmapAndClearShape();
			endifFlash*/

			var newMatrix:Matrix = new Matrix();
			newMatrix.scale(xy,xy);
			newMatrix.concat(shapeMatrix);
			shapeMatrix = newMatrix;
			
			trackingScaleX *= xy;
			trackingScaleY *= xy;

			newShapeNeeded = true;
		}

		public function translateArgCount2( x:Float, y:Float ):Void
		{
			/*ifFlash
				// draw the shape to bitmap before we
				// change the transformation matrix
				drawShapeToBitmapAndClearShape();
			endifFlash*/
			
			var newMatrix:Matrix = new Matrix();
			newMatrix.translate(x, y);

			trackingTranslationX += x;
			trackingTranslationY += y;
			
			newMatrix.concat(shapeMatrix);
			shapeMatrix = newMatrix;

			newShapeNeeded = true;
		}

		public function strokeWeightArgCount1( w:Float ):Void
		{
			curStrokeWeight = w;
			// set stroke
			if (doStroke)
				shape.graphics.lineStyle(curStrokeWeight , curStrokeColor & 0xFFFFFF,
				    pGraphicsAlphaMethod(curStrokeColor) / 255,  LineScaleMode.NONE, CapsStyle.ROUND);
		}

		public function pointArgCount2( x:Float, y:Float ):Void {
		
			// first, figure out where the point should end up, according
			// to the current transformation matrix
			
			var point:Point = new Point();
			point.x = x;
			point.y = y;
	
	
			var pointPosition:Point;
			pointPosition = shapeMatrix.transformPoint(point);
			
	
			// ok now we draw the rectangle of 1px by 1px.
			// Note that the rectangle now should be in the right place and the right size
			// but should not be rotated
	
			// let's draw no stroke, the point is made entirely of the fill
			shape.graphics.lineStyle();
	
			// we draw the fill of the rectangle, but the color is the one we degined with
			// the stroke primitive, so we look at curStrokeColor instead of curFillColor
			shape.graphics.beginFill(curStrokeColor & 0xFFFFFF, pGraphicsAlphaMethod(curStrokeColor) == 255 ? 255 : pGraphicsAlphaMethod(curStrokeColor) / 312);
	
			//pointPosition.x -= (1 / 2);
			//pointPosition.y -= (1 / 2);
			shape.graphics.drawEllipse(pointPosition.x-curStrokeWeight*trackingScaleX/2, pointPosition.y-curStrokeWeight*trackingScaleY/2, curStrokeWeight*trackingScaleX + 1, curStrokeWeight*trackingScaleY + 1);
			//shape.graphics.drawRect(pointPosition.x, pointPosition.y, curStrokeWeight*trackingScaleX , curStrokeWeight*trackingScaleY );
				
			shape.graphics.endFill();
	
			// rasterize and clear shape
			// [todo] I think that this clear() is not right, that will
			// clear all styles and transforms, so I really think there
			// is something wrong with that one
			/*ifFlash
				bitmapData.draw(shape, null, null, null, null, doSmooth);
				shape.graphics.clear();
			endifFlash*/
			
			// then, draw it as a rectangle of the appropriate scale (the trick here is that we don't have
			// to rotate the rectangle)
			
			/*
			if (curStrokeColor & 0xFF000000){
				bitmapData.setPixel32(x, y, curStrokeColor);		
			}
			curStrokeColor = curStrokeColor | 0x09000000;
			*/

		}

		public function beginShapeArgCount0(): Void
		{
			//[TODO] prevent other shapes from drawing until endShape
			curShape = POLYGON;
			curShapeCount = 0; 
			curvePoints = [];
		}

		public function beginShapeArgCount1( type:Int ): Void
		{
			//[TODO] prevent other shapes from drawing until endShape
			curShape = type;
			curShapeCount = 0; 
			curvePoints = [];
		}

		public function endShapeArgCount0( ): Void{
			if ( curShapeCount != 0  || pathOpen ) {
				endAnyOpenFills();
				curShapeCount = 0;
				pathOpen = false;

				// we re-open the fill here.
				// If we don't reopen the fill then some of the further
				// drawings within this shape might not be drawn.
				// Remember that a new shape is created only if a matrix
				// tranformation happens. So, if we are stuck to a shape and we
				// want to draw several triangles, which are drawn as filled shapes,
				// then we have to reopen the fill, we can't just close it, otherwise
				// only the first triangle is drawn.
				// Ideally we should only re-begin the fill if there is any need
				// for it later on, i.e. we should begin the fill only when and where
				// we need it to be begun and there isn't one available, by using a
				// flag like beginFillIsOpen.
				if (doFill)
					shape.graphics.beginFill(curFillColor & 0xFFFFFF, pGraphicsAlphaMethod(curFillColor) / 255);
			}
		}
		
		public function endShapeArgCount1( close: Bool ): Void
		{
			shape.graphics.lineTo( firstX, firstY );
			
			if ( curShapeCount != 0  || pathOpen ) {
				endAnyOpenFills();
				curShapeCount = 0;
				pathOpen = false;
			}
		}

		public function vertexArgCount2( x: Float, y: Float )
		{
			if ( curShapeCount == 0 && curShape != POINTS )
			{
				pathOpen = true;
				if (newShapeNeeded) beginShapeDrawing();
				shape.graphics.moveTo( x, y );
				firstX = x;
				firstY = y;
			}
			else
			{
				if ( curShape == POINTS )
				{
					pointArgCount2( x, y );
				}
				else {
					if ( curShape != QUAD_STRIP || curShapeCount != 2 )
						shape.graphics.lineTo( x, y );
	
					if ( curShape == TRIANGLE_STRIP ) {
						if ( curShapeCount == 2 ) {
							// finish shape
							endShapeArgCount1(CLOSE);
							pathOpen = true;
							if (newShapeNeeded) beginShapeDrawing();
							
							// redraw last line to start next shape
							shape.graphics.moveTo( prevX, prevY );
							shape.graphics.lineTo( x, y );
							curShapeCount = 1;
						}
						firstX = prevX;
						firstY = prevY;
					}
	
					if ( curShape == TRIANGLE_FAN && curShapeCount == 2 ) {
						// finish shape
						endShapeArgCount1(CLOSE);
						pathOpen = true;
						if (newShapeNeeded) beginShapeDrawing();
				
						// redraw last line to start next shape
						shape.graphics.moveTo( firstX, firstY );
						shape.graphics.lineTo( x, y );
						curShapeCount = 1;
					}
			
					if ( curShape == QUAD_STRIP && curShapeCount == 3 ) {
						// finish shape
						shape.graphics.lineTo( prevX, prevY );
						endShapeArgCount1(CLOSE);
						pathOpen = true;
						if (newShapeNeeded) beginShapeDrawing();
			
						// redraw lines to start next shape
						shape.graphics.moveTo( prevX, prevY );
						shape.graphics.lineTo( x, y );
						curShapeCount = 1;
					}
	
					if ( curShape == QUAD_STRIP) {
						firstX = secondX;
						firstY = secondY;
						secondX = prevX;
						secondY = prevY;
					}
				//} else if ( arguments.length == 4 ) {
				//	if ( curShapeCount > 1 ) {
				//		shape.graphics.moveTo( prevX, prevY );
				//		shape.graphics.curveTo(firstX, firstY, x, y);
				//		curShapeCount = 1;
				//	}
				//} else if ( arguments.length == 6 ) {
				//	shape.graphics.lineTo(x, y); 
				//	(new Bezier(shape.graphics)).drawCubicBezier(
				//		new Point(prevX, prevY), new Point(x, y), new Point(x2, y2), new Point(x3, y3), 4);
				//	curShapeCount = -1;
				//	// make sure prevX/prevY are set to next point
				//	x = x3;
				//	y = y3;
				}
			}
	
			prevX = x;
			prevY = y;
			curShapeCount++;
			
			if ( curShape == LINES && curShapeCount == 2 ||
					 (curShape == TRIANGLES) && curShapeCount == 3 ||
			 (curShape == QUADS) && curShapeCount == 4 ) {
				endShapeArgCount1(CLOSE);
			}
	} // closes method

	public function vertexArgCount4( x:Float, y:Float, x2:Float, y2:Float ) {
			if ( curShapeCount == 0 && curShape != POINTS )
			{
				pathOpen = true;
				if (newShapeNeeded) beginShapeDrawing();
				shape.graphics.moveTo( x, y );
				firstX = x;
				firstY = y;
			}
			else
			{
				if ( curShape == POINTS )
				{
					pointArgCount2( x, y );
				}
				else  {
					if ( curShapeCount > 1 ) {
						shape.graphics.moveTo( prevX, prevY );
						shape.graphics.curveTo(firstX, firstY, x, y);
						curShapeCount = 1;
					}
				}
			}
	
			prevX = x;
			prevY = y;
			curShapeCount++;
			
			if ( curShape == LINES && curShapeCount == 2 ||
					 (curShape == TRIANGLES) && curShapeCount == 3 ||
			 (curShape == QUADS) && curShapeCount == 4 ) {
				endShapeArgCount1(CLOSE);
			}
	} // closes method

	public function vertexArgCount6( x:Float, y:Float, x2:Float, y2:Float , x3:Float, y3:Float ) {
			if ( curShapeCount == 0 && curShape != POINTS )
			{
				pathOpen = true;
				if (newShapeNeeded) beginShapeDrawing();
				shape.graphics.moveTo( x, y );
				firstX = x;
				firstY = y;
			}
			else
			{
				if ( curShape == POINTS )
				{
					pointArgCount2( x, y );
				}
				else {
					//shape.graphics.lineTo(x, y); 
					drawCubicBezier2(prevX, prevY, x, y, x2, y2, x3, y3);
					//curShapeCount = -1;
					// make sure prevX/prevY are set to next point
					x = x3;
					y = y3;
				}
			}
	
			prevX = x;
			prevY = y;
			curShapeCount++;
			
			if ( curShape == LINES && curShapeCount == 2 ||
					 (curShape == TRIANGLES) && curShapeCount == 3 ||
			 (curShape == QUADS) && curShapeCount == 4 ) {
				endShapeArgCount1(CLOSE);
			}
	} // closes method

		public function bezierVertexArgCount6(x, y, x2, y2, x3, y3 ):Void {
			vertexArgCount6(x, y, x2, y2, x3, y3 );
		}

		public function curveVertexArgCount2( x:Float, y:Float):Void {
			if ( curvePoints.length < 3 ) {
				curvePoints.push(new Point(x,y));
			} else {
				var b = new Array();
				var s = 1 - curTightness;
	
				/*
				 * Matrix to convert from Catmull-Rom to cubic Bezier
				 * where t = curTightness
				 * |0				 1					0				 0			 |
				 * |(t-1)/6	 1					(1-t)/6	 0			 |
				 * |0				 (1-t)/6		1				 (t-1)/6 |
				 * |0				 0					0				 0			 |
				 */
	
				curvePoints.push(new Point(x,y));
	
				b[0] = [curvePoints[1].x,curvePoints[1].y];
				b[1] = [curvePoints[1].x+(s*curvePoints[2].x-s*curvePoints[0].x)/6,curvePoints[1].y+(s*curvePoints[2].y-s*curvePoints[0].y)/6];
				b[2] = [curvePoints[2].x+(s*curvePoints[1].x-s*curvePoints[3].x)/6,curvePoints[2].y+(s*curvePoints[1].y-s*curvePoints[3].y)/6];
				b[3] = [curvePoints[2].x,curvePoints[2].y];
				
				if ( !pathOpen ) {
					vertexArgCount2( b[0][0], b[1][1] );
				} else {
					curShapeCount = 1;
				}
	
				vertexArgCount6( b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1] );
				curvePoints.shift();
			}
		}
	
		public function curveTightness( tightness:Float ):Void {
			curTightness = tightness;
		}

	public function bezierArgCount8( x1: Float, y1: Float, x2: Float, y2: Float, x3: Float, y3: Float, x4: Float, y4: Float )
	{
		//			curContext.lineCap = "butt";
		if (newShapeNeeded) beginShapeDrawing();
        shape.graphics.moveTo(x1, y1);
        drawCubicBezier2(x1, y1, x2, y2, x3, y3, x4, y4);
		endAnyOpenFills();
    }

	/////////////////////////////////////////////////////////////////////////
	//
	// Draws a bezier curve using the midPoint algorithm by Helen Triolo
	// This function will trace an approximation of the cubic Bezier
	// by turning it into 4 quadratic beziers
	// (which Flash can handle through the Graphics.curveTo method)
	// It will calculate a serie of [control point/Destination point] which 
	// will be used to draw quadratic Bezier starting from P0
	//
	// Further discussion and code from here:
	// http://www.timotheegroleau.com/Flash/articles/cubic_bezier_in_flash.htm
	//
	/////////////////////////////////////////////////////////////////////////
	
	public function drawCubicBezier2(x1:Float ,y1: Float, x2: Float,y2: Float, x3: Float,y3: Float, x4: Float,y4: Float):Void {
	
		// calculates the useful base points
		var PA:Point = getPointOnSegment(x1,y1, x2,y2, 3/4);
		var PB:Point = getPointOnSegment(x4,y4, x3,y3, 3/4);
		
		// get 1/16 of the [P3, P0] segment
		var dx:Float = (x4 - x1)/16;
		var dy:Float = (y4 - y1)/16;
		
		// calculates control point 1
		var Pc_1:Point = getPointOnSegment(x1,y1, x2,y2, 3/8);
		
		// calculates control point 2
		var Pc_2:Point = getPointOnSegment(PA.x,PA.y, PB.x,PB.y, 3/8);
		Pc_2.x -= dx;
		Pc_2.y -= dy;
		
		// calculates control point 3
		var Pc_3:Point = getPointOnSegment(PB.x,PB.y, PA.x,PA.y, 3/8);
		Pc_3.x += dx;
		Pc_3.y += dy;
		
		// calculates control point 4
		var Pc_4:Point = getPointOnSegment(x4,y4, x3,y3, 3/8);
		
		// calculates the 3 anchor points
		var Pa_1:Point = getMiddle(Pc_1.x,Pc_1.y, Pc_2.x,Pc_2.y);
		var Pa_2:Point = getMiddle(PA.x,PA.y, PB.x,PB.y);
		var Pa_3:Point = getMiddle(Pc_3.x,Pc_3.y, Pc_4.x, Pc_4.y);
	
		// draw the four quadratic subsegments
		shape.graphics.curveTo(Pc_1.x, Pc_1.y, Pa_1.x, Pa_1.y);
		shape.graphics.curveTo(Pc_2.x, Pc_2.y, Pa_2.x, Pa_2.y);
		shape.graphics.curveTo(Pc_3.x, Pc_3.y, Pa_3.x, Pa_3.y);
		shape.graphics.curveTo(Pc_4.x, Pc_4.y, x4, y4);
	}

	// return the middle of a segment define by two points
	private static inline function getMiddle(x1: Float,y1: Float, x2: Float,y2: Float):Point {
		return new Point(((x1 + x2) / 2),((y1 + y2) / 2));
	}
	
	// return a point on a segment [P0, P1] which distance from P0
	// is ratio of the length [P0, P1]
	private static inline function getPointOnSegment(x1: Float,y1: Float, x2: Float,y2: Float, ratio:Float):Point {
		return new Point((x1 + ((x2 - x1) * ratio)),(y1 + ((y2 - y1) * ratio)));
	}


}  // closes class

